# PowerShell コーディングスタンダード（MD-WBS Tools Project）

## 0. はじめに - このドキュメントの目的と開発哲学

### 0.1. このドキュメントの目的

このドキュメントは、MD-WBS ToolsプロジェクトにおけるPowerShellスクリプト開発の品質、一貫性、保守性、堅牢性を最大限に高めるためのコーディング規約とベストプラクティスを定義する。
すべての開発者（人間およびAI支援ツールを含む）は、ここに記述された規約を遵守することが求められる。
この規約は、過去のデバッグ経験で直面した多くの課題と、その解決から得られた教訓に基づいている。

### 0.2. 開発哲学

1. **「意図」の明示化と共有（Clarity of Intent）**
    * **なぜ？**: コードの各部分（変数、関数、`パラメータ`、モジュール）が「何をするのか」「なぜそうするのか」が明確でなければ、誤解や誤用を生み、バグの温床となる。たとえば、関数`パラメータ`の型や名前が不明確であったために、`パラメータ`バインディングエラーが繰り返し発生し、デバッグに多大な時間を要した。変数名からそのスコープや目的が推測できないと、意図しない副作用を生む可能性がある。
    * **どうする？**: 意味のある命名、厳密な型指定、適切なコメント、明確な関数シグネチャ、モジュール設計を通じて、コードの意図を明確に表現する。

2. **「単純さ」の追求（Simplicity）**
    * **なぜ？**: 複雑なコードは理解しにくく、変更しにくく、テストしにくい。PowerShellのパイプラインやオブジェクト指向の特性を活かしつつも、不必要に技巧的なコードや、過度にネストしたロジックは避けるべきである。
    * **どうする？**: 単一責任の原則に従い、関数やモジュールを小さく保つ。可能な限りPowerShellの標準的な機能やイディオムを活用する。複雑な処理は、より小さなステップに分割する。

3. **「影響範囲」の意識と管理（Consciousness of Impact）**
    * **なぜ？**: コードの一部分の変更や、ある機能の実行が、システムの他の部分や外部環境（ファイルシステム、COMオブジェクトなど）にどのような影響を与えるかを常に意識する必要がある。たとえば、モジュールロード時の安易な標準出力が、Pesterのようなテストフレームワークのパーサーに予期せぬ影響を与えた。COMオブジェクトの解放漏れは、Excelプロセスが残存し、ファイルロックの原因となった。
    * **どうする？**: スコープの適切な管理、副作用の最小化、リソースの確実な解放、エラーハンドリングの徹底を通じて、影響範囲を限定し、制御する。

4. **「再現性」と「予測可能性」の確保（Reproducibility and Predictability）**
    * **なぜ？**: 同じ入力に対して常に同じ結果を返すこと、そしてコードの動作が予測可能であることは、信頼性の高いシステムを構築する上で不可欠である。とくに、外部状態に依存する処理や、エラーハンドリングが不十分な処理は、予測不可能な動作を引き起こしやすい。
    * **どうする？**: 厳密な入力検証、状態管理の明確化、冪等性（可能な場合）の考慮、網羅的なテストを通じて、コードの動作の再現性と予測可能性を高める。

5. **「学習」と「改善」の継続（Continuous Learning and Improvement）**
    * **なぜ？**: 開発プロセスで発生した問題やエラーは、貴重な学習機会である。これらの教訓を規約やベストプラクティスに反映し、将来の同様の問題を防ぐことが重要である。
    * **どうする？**: このコーディングスタンダード自体を、プロジェクトの進行とともに見直し、更新していく。新たな知見や問題点が発生した場合は、積極的に本文書に追記・修正する。

## 1. 基本規約: 必須事項と推奨事項

### 1.1. 環境設定（必須）

* **1.1.1. `Set-StrictMode -Version Latest`**: すべての `.ps1`, `.psm1` ファイルの冒頭（`#Requires` の直後、`param` ブロックの前など）に記述する。
* **理由**: 未定義変数へのアクセス、存在しないプロパティへのアクセス、関数呼び出し時の括弧の省略などをエラーとして扱い、潜在的なバグを早期に発見するため。（開発哲学: 1, 4）
* **1.1.2. `$ErrorActionPreference = "Stop"`**: スクリプトのグローバルスコープ（または主要な処理ブロックの先頭）で設定する。
* **理由**: コマンドレットが出すノンターミネーティングエラーをターミネーティングエラーに変換し、`try-catch` で確実に捕捉できるようにするため。これにより、エラー発生時の処理フローが予測可能になる。（開発哲学: 3, 4）

### 1.2. 命名規則（推奨）

* **1.2.1. 変数**:
  * ローカル変数、`パラメータ`: `$camelCase`（例: `$inputFilePath`, `$retryCount`）
  * スクリプトスコープ変数: `$script:PascalCase`（例: `$script:LogFilePath`）
  * グローバルスコープ変数: 原則として使用を避ける。必要な場合は `$global:PascalCase` とし、使用理由をコメントで明記。
  * **意味とスコープが明確な名前を選ぶ。** 短い略語よりも明確な単語を優先。
  * Boolean型変数: `$isReady`, `$hasError` のように、状態が明確にわかる接頭辞を推奨。
  * **理由**: 変数の目的とスコープを明確にし、コードの可読性を高め、意図しない副作用を防ぐ。（開発哲学: 1）
* **1.2.2. 関数・コマンドレット**: `Verb-Noun` 形式（PascalCase）。`Get-Verb` で表示される承認された動詞を使用する。
  * **理由**: PowerShellの標準的な命名規則に従うことで、他の開発者（AI含む）が関数の目的を理解しやすくなる。（開発哲学: 1）
* **1.2.3. `パラメータ`**: `$camelCase`。関数/コマンドレットの`パラメータ`名は、標準コマンドレットの慣習に可能な限り従う（例: `-Path`, `-Identity`, `-Force`）。
  * **理由**: 標準的な`パラメータ`名を使用することで、関数の使い方を類推しやすくする。（開発哲学: 1, 2）

### 1.3. コメント（推奨）

* **1.3.1. スクリプト/`関数ヘッダ`**: `<# .SYNOPSIS ... #>` 形式で目的、`パラメータ`、戻り値、使用例などを記述する。
  * **理由**: スクリプトや関数の全体像と使い方を素早く理解できるようにするため。（開発哲学: 1）
* **1.3.2. ロジック説明**: 複雑な処理、特定のアルゴリズム選択の理由、前提条件、潜在的な副作用、ワークアラウンドなどを記述する。「なぜ」そのコードが必要なのかを説明する。
  * **理由**: コードの意図や背景を補足し、将来の保守性や改修時の誤解を防ぐ。（開発哲学: 1, 5）
* **1.3.3. アノテーション**: `TODO:`, `FIXME:`, `NOTE:` などの標準的なアノテーションを使用して、将来の作業や注意点を明示する。
  * **理由**: 未完了のタスクや既知の問題点を明確にし、見落としを防ぐ。（開発哲学: 5）

## 2. `パラメータ`処理の規約（最重要・過去の教訓）

### 2.1. 関数`パラメータ`の厳密な定義（必須）

* **2.1.1. `[CmdletBinding（）]` 属性**: 原則としてすべての推奨関数に付与する。
  * **理由**: `-Verbose`, `-Debug`, `-ErrorAction` などの共通`パラメータ`をサポートし、より堅牢で使いやすい関数にするため。（開発哲学: 1, 4）
* **2.1.2. 型指定**: すべての`パラメータ`に厳密な型を指定する（`[string]`, `[int]`, `[datetime]`, `[object[]]`, `[System.Collections.Generic.List[YourClass]]`, `[switch]` 等）。
  * **理由**: 型安全性を高め、意図しない型変換によるバグを防ぐ。PowerShellが`パラメータ`の値を期待する型に変換しようとする際の曖昧さを排除する。（開発哲学: 1, 4）
* **2.1.3. 必須属性**: 必須`パラメータ`には `[Parameter（Mandatory=$true）]` を明記する。
  * **理由**: 関数が正しく動作するために不可欠な情報が確実に提供されるようにする。（開発哲学: 1, 4）
* **2.1.4. デフォルト値**: オプション`パラメータ`には必ず意味のあるデフォルト値を設定する。
  * **理由**: `パラメータ`が省略された場合の動作を明確にし、予測可能性を高める。（開発哲学: 1, 4）
* **全体理由**: **今回のデバッグでもっとも多くの時間を費やしたのが、`パラメータ`の型不一致、必須`パラメータ`の欠落、デフォルト値の不備に起因する `ParameterBindingException` や予期せぬ対話的入力要求であった。これらの問題を根絶するため、`パラメータ`定義は最大限厳密に行う。**（開発哲学: 1, 4, 5）

### 2.2. 関数呼び出し時の引数の整合性（必須）

* **2.2.1. `パラメータ`名と値の完全一致**: 関数を呼び出す際は、`パラメータ`名（`-ParameterName`）と渡す変数/値が、関数定義側の名前、型、順序（位置指定の場合）と完全に一致していることを確認する。
  * **理由**: タイプミスや変数名の混同による`パラメータ`バインディングエラーを防止する。これも今回多発した問題である。（開発哲学: 1, 4, 5）
* **2.2.2. スプラッティングの活用と注意**: 多数の`パラメータ`を渡す場合は、ハッシュテーブルとスプラッティング（`@params`）を活用する。その際、ハッシュテーブルのキー名が`パラメータ`名と完全に一致していることを保証する。
  * **理由**: コードの可読性を向上させつつ、`パラメータ`名の整合性を確保する。（開発哲学: 1, 2）

### 2.3. 変数スコープと`パラメータ`の受け渡し（推奨）

* **2.3.1. スクリプト`パラメータ`の引き継ぎ**: スクリプト全体で受け取った`パラメータ`を内部関数に渡す際は、明示的に`パラメータ`として渡す。内部関数がスクリプトスコープ変数を直接参照することは極力避ける。
  * **理由**: 関数の独立性と再利用性を高め、スコープによる混乱を防ぐ。関数のテストが容易になる。（開発哲学: 2, 3）

## 3. エラーハンドリングとロギングの規約（必須）

### 3.1. クリティカル処理の `try-catch-finally`（必須）

* **3.1.1. 対象**: ファイルI/O（`Get-Content`, `Set-Content`, `Test-Path` の後の実処理など）、COMオブジェクト操作、API呼び出し、外部コマンド実行、複雑なデータ変換や計算など、失敗する可能性のあるすべてのクリティカルな処理。
  * **理由**: 予期せぬエラーが発生した場合でも、スクリプトが安全に終了するか、適切に処理を継続できるようにするため。（開発哲学: 3, 4）
* **3.1.2. `catch` ブロック**:
  * エラーを捕捉し、適切なログ出力、ユーザーへの通知、リソース解放、または安全な終了処理を行う。
  * **具体的なエラー情報のログ出力**: 開発者向けには `Write-Verbose "ERROR: $($_.Exception.Message)at $($_.InvocationInfo.ScriptName):$($_.InvocationInfo.ScriptLineNumber)"` のように詳細情報を出力。
  * **ユーザー向けエラーメッセージ**: `Write-Error` で簡潔かつ対処のヒントとなるメッセージを表示。**`Write-Error` には `-ForegroundColor` を使用しない。**（理由は7.1参照）
  * **処理継続判断**: 処理継続が不可能な場合は、`throw` でエラーを再スローするか `exit 1` でスクリプトを終了する。
  * **とくに注意（二次エラー防止）**: `catch` ブロック内でエラーメッセージを組み立てる際、`$_.Exception.Message` や `$Element.Id` などを文字列展開する場合は、それらが予期せぬ型（数値など）でないことを保証するため、`.ToString（）` を明示的に付加するか、安全な文字列結合（例: `-join` やフォーマット文字列）を行う。**今回のデバッグでは、`catch` ブロック内での二次的な型キャストエラーに悩まされた。**（開発哲学: 3, 4, 5）
* **3.1.3. `finally` ブロック**: 確保したリソース（とくにCOMオブジェクト、ファイルハンドル、ネットワーク接続など）を確実に解放する処理を記述する。
  * **理由**: リソースリークを防ぎ、システムの安定性を保つため。（開発哲学: 3）

### 3.2. ログ出力レベルの使い分け（推奨）

* **`Write-Verbose`**: スクリプトの主要な処理ステップの開始・終了、重要な変数の状態変化、条件分岐の結果など、スクリプトの動作を追跡するのに役立つ情報を出力する。ユーザーが `-Verbose` スイッチを付けた場合に表示される。
* **`Write-Debug`**: より詳細な内部状態、ループ内の変数、複雑な計算の途中結果など、開発者向けのデバッグ情報を出力する。ユーザーが `-Debug` スイッチを付けた場合に表示され、ブレークポイントの設定も可能。
* **`Write-Warning`**: 処理は続行できるものの、潜在的な問題がある場合や、ユーザーに注意を促したい場合に使用する（例: ファイルが見つからない場合デフォルト値で続行、一部データが不正だがスキップして処理など）。**`-ForegroundColor` は使用しない。**（理由は7.1参照）
* **`Write-Host`**: ユーザーへの直接的な通知や、テストランナーのようなスクリプトからの主要な進捗表示に限定的に使用する。デバッグ目的での多用は避け、`Write-Verbose` を優先する。**`-ForegroundColor` は適切に使用する。**
* **理由**: ログの目的と対象者に応じて適切なコマンドレットを使い分けることで、デバッグ効率とユーザーエクスペリエンスを向上させる。（開発哲学: 1, 3）

## 4. COMオブジェクト（とくにExcel）操作の規約（必須）

### 4.1. オブジェクトの厳密な解放（必須）

* **4.1.1. `finally` ブロックでの解放**: Excelオブジェクト（`Application`, `Workbook`, `Worksheet` 等）は、必ず `try-catch-finally` の `finally` ブロックで解放する。
* **4.1.2. 解放手順**:
    1. `$Worksheet = $null`（参照をまず切る）
    2. `$Workbook.Close（$SaveChanges）`（適切な保存オプションを指定）
    3. `$Workbook = $null`
    4. `$Excel.Quit（）`
    5. `$Excel = $null`
    6. `[System.Runtime.InteropServices.Marshal]::ReleaseComObject（$WorksheetInstance）`（実際のCOMオブジェクトインスタンスに対して）
    7. `[System.Runtime.InteropServices.Marshal]::ReleaseComObject（$WorkbookInstance）`
    8. `[System.Runtime.InteropServices.Marshal]::ReleaseComObject（$ExcelInstance）`
    9. `[System.GC]::Collect（）`
    10. `[System.GC]::WaitForPendingFinalizers（）`
  * **注意**: 上記は一般的な順序だが、オブジェクトの親子関係や参照の持ち方によって調整が必要な場合がある。重要なのは、すべてのCOMオブジェクト参照が解放されること。変数を `$null` にするだけでなく、`ReleaseComObject` を確実に呼び出す。
* **理由**: **Excelプロセスがバックグラウンドに残存し、ファイルロックやリソースリークを引き起こす最大の原因となるため、これを徹底する。**（開発哲学: 3, 4, 5）

### 4.2. 初期設定（推奨）

* **4.2.1. `$excel.Visible = $false`**: バックグラウンドで実行し、`ユーザーインターフェース`を表示しない。
* **4.2.2. `$excel.DisplayAlerts = $false`**: 確認ダイアログ等で処理が中断するのを防ぐ。
* **4.2.3. `$excel.ScreenUpdating = $false`**: 大量のセル操作を行う場合、画面更新を抑制してパフォーマンスを向上させる。処理後に `$true` に戻すか、Excelを終了する。
* **理由**: スクリプトの実行効率と安定性を高めるため。（開発哲学: 3, 4）

### 4.3. セルへの値設定（推奨）

* **4.3.1. `.Value2` プロパティ**: 原則としてセルへの値の読み書きには `.Value2` を使用する。これは書式情報を含まない純粋な値を取得・設定するため、予期せぬ型変換を防ぎやすい。
* **4.3.2. データ型**:
  * 数値: `[int]`, `[double]` 型のまま設定。
  * 日付: `[datetime]` オブジェクトを設定。Excel側で日付シリアル値に変換される。表示書式は `.NumberFormat` で制御。
  * 文字列: 文字列として設定。
* **4.3.3. 書式設定**: 数値や日付の表示書式は、値を設定した後にセルの `.NumberFormat` プロパティで設定する（例: `$cell.NumberFormat = "yyyy-mm-dd"`, `$cell.NumberFormat = "0.00%"`)。
* **とくに注意（NumberFormat適用時のエラー対策）**: **今回、数値（とくに `double`）をセルに設定し、その後 `.NumberFormat = "0%"` のような書式を適用する際に「`Unable to cast object of type 'System.Double' to type 'System.String'.`」という不可解なエラーに遭遇した。これは、セルの既存書式やCOMの内部状態が影響している可能性が考えられる。対策として、値を設定する前に `$cell.NumberFormat = "General"` で書式をいったんリセットすることを試行し、効果があった。このパターンをベストプラクティスとして記録する。**（開発哲学: 3, 4, 5）

### 4.4. OneDrive同期`フォルダ`での注意（推奨）

* **4.4.1. ローカル非同期`フォルダ`の利用**: ExcelファイルをCOM経由で頻繁に読み書きする場合、OneDriveなどの同期`フォルダ`内ではファイルロックやパス解釈の問題が発生しやすい。可能な限りローカルの非同期`フォルダ`（例: `C:\Temp`）で作業し、処理完了後に同期`フォルダ`にコピー/移動することを推奨する。**今回、この変更でファイルアクセスエラーが解消した。**
* **理由**: ファイルシステムの同期処理とCOM操作の競合を避け、安定した動作を確保するため。（開発哲学: 3, 4, 5）

## 5. モジュール設計の規約（必須）

### 5.1. 共通関数の集約（`MyCommonFunctions.psm1`）

* **5.1.1. 対象**: 複数のメインスクリプトで共通して利用される関数（MD-WBSパース、日付計算、祝日処理など）、およびクラス定義（`WbsElementNode`, `ProjectMetadata`）。
* **理由**: コードのDRY原則を徹底し、保守性を一元化する。変更が一箇所で済むようにする。（開発哲学: 2, 3）

### 5.2. マニフェストファイル（`MyCommonFunctions.psd1`）の厳格な記述（必須）

* **5.2.1. 必須キー**: `ModuleVersion`, `GUID`（一意の値を生成して使用）, `Author`, `Description`, `RootModule`（`.psm1`ファイル名）, `FunctionsToExport`（エクスポートする関数名の配列）などを正確に記述する。
* **5.2.2. コマンド展開の禁止**: **マニフェストファイル内では `$（...）` のようなコマンド展開は使用しない。** これが原因でモジュールインポートエラーが発生した。すべての値は静的な文字列またはデータ構造で記述する。
* **理由**: モジュールのメタデータを正確に定義し、PowerShellがモジュールを正しく認識・ロードできるようにするため。コマンド展開はマニフェストの静的な性質を損なう。（開発哲学: 1, 3, 4, 5）

### 5.3. モジュールロード時の副作用排除（必須）

* **5.3.1. 標準出力への書き出し禁止**: `.psm1` ファイルのトップレベル（関数外）では、`Write-Host` などで標準出力に書き出す処理を行わない。これがPesterのパーサーエラーの一因となった可能性がある。デバッグ情報は関数内の `Write-Verbose` を使用する。
* **理由**: モジュールのインポートは、そのモジュールが提供する機能を利用可能にするための準備であり、予期せぬ出力や状態変更を引き起こすべきではない。これは他のツールやスクリプトとの連携時に問題となる。（開発哲学: 3, 4, 5）

## 6. テストスクリプト（*.Tests.ps1）の規約（Pester利用時）

Pesterを用いたユニットテストおよび統合テストを作成する際の規約を以下に定める。

### 6.1. Pester構文（必須）

* **6.1.1. Pesterバージョン**: 本プロジェクトではPester 5.xを標準とする。
* **6.1.2. アサーション構文**: アサーション（検証）は、`Should -Be <期待値>` や `Should -Throw` のように、マッチャーの前にハイフン（`-`）を付与するPester 5.xの標準構文を使用する。
  * **理由**: Pester 5.xではハイフンなしのレガシー構文はサポートされておらず、エラーの原因となるため。（開発哲学: 1, 4, 5）
  * **例（良い例）**: `$result | Should -Be "expected"`
  * **例（悪い例）**: `$result | Should Be "expected"`

### 6.2. モジュールのインポート（必須）

* **6.2.1. インポート方法**: テスト対象のモジュールは、テストスクリプトの**先頭**（`Describe` ブロックの外）で、モジュールマニフェストファイル（`.psd1`）への相対パス（`$PSScriptRoot` を基準とする）を解決し、その**フルパス**を用いて `Import-Module -Name <フルパス> -Force -ErrorAction Stop` を使用して一度だけインポートすることを原則とする。
  * **理由**: テスト実行前に確実に対象モジュールをロードし、パスの曖昧さによるエラーを排除するため。`-Force` で最新の状態を保証し、`-ErrorAction Stop` でインポート失敗時に即座にテストを停止させることで問題に早期に気づけるようにする。（開発哲学: 1, 3, 4, 5）
  * **コード例**:

        ```powershell
        # スクリプトの先頭
        try {
            $modulePath = Join-Path $PSScriptRoot "../../src/powershell/Modules/MyCommonFunctions/MyCommonFunctions.psd1"
            Import-Module -Name $modulePath -Force -ErrorAction Stop
        }
        catch {
            Write-Error "テストの前提条件であるモジュールのインポートに失敗しました。パス: '$modulePath' Error: $($_.Exception.Message)"
            return # モジュールインポート失敗時はテストを続行しない
        }
        ```

* **6.2.2. モジュールのアンロード**: テストスクリプトの最後（例: `AfterAll` ブロック、またはスクリプトの末尾）で、インポートしたモジュールを `Remove-Module <モジュール名> -Force -ErrorAction SilentlyContinue` を使用してアンロードすることを推奨する。
  * **理由**: テストセッション間の状態の干渉を防ぎ、クリーンなテスト環境を維持するため。（開発哲学: 3, 4）

### 6.3. テストの独立性と状態管理（必須）

* **6.3.1. 状態のリセット**: 状態を持つ関数（例: グローバル変数やスクリプトスコープのカウンターに依存する関数）をテストする場合、各テスト（`It` ブロック）の独立性を確保するために `BeforeEach` ブロックでリセット用の関数（例: `Reset-WbsCounters`）を呼び出す。
  * **理由**: あるテストの実行結果が他のテストに影響を与えないようにし、テストの信頼性と再現性を高めるため。（開発哲学: 4）
  * **コード例**:

        ```powershell
        Describe "MyStatefulFunction Tests" {
            BeforeEach {
                Reset-MyStatefulCounters # 状態をリセットする関数
            }

            It "Should do X when state is A" {
                # ... test logic ...
            }
        }
        ```

### 6.4. ファイルエンコーディング（必須）

* **6.4.1. エンコーディング**: テストスクリプトファイル（`*.Tests.ps1`）は、**UTF-8 with BOM** で保存する。
  * **理由**: PowerShellスクリプトの標準的なエンコーディングであり、とくに日本語などのマルチバイト文字を含む場合に文字化けを防ぎ、異なる環境間での互換性を高めるため。PowerShellエンジンがBOMを認識して正しくファイルを解釈する。（開発哲学: 4）

### 6.5. テストデータの品質と仕様準拠（必須）

* **6.5.1. 仕様準拠**: すべてのテストデータ（`.md`ファイル、`.csv`ファイル、モックオブジェクト等）は、`12_wbs_task_syntax_specification.md` や `10_requirements_definition.yaml` などの関連仕様書に厳密に準拠して作成する。
* **理由**: 仕様と乖離したテストデータは、ツールの予期せぬ動作を引き起こし、デバッグを困難にする。過去の経験から、`パラメータ`数の不一致や不正なフォーマットのデータが原因で、多くの手戻りが発生したため、これを徹底する。（開発哲学: 4, 5）
* **6.5.2. エラーケースの明示**: 意図的に仕様から逸脱させたデータ（例: 必須`パラメータ`の欠落、不正なフォーポート、重複ID）を用いてエラーハンドリングをテストする場合は、そのテストケース（`It` ブロック）の名称やコメントで、それが意図的なエラーケースであることを明確に記述する。
* **理由**: テストの意図を明確にし、将来の保守者がテストの失敗を正常な動作（エラーを正しく検知した結果）と誤解しないようにするため。（開発哲学: 1）

## 7. その他（固有の教訓）

### 7.1. `-ForegroundColor` の誤用（必須知識）

* **内容**: `Write-Error` および `Write-Warning` コマンドレットは `-ForegroundColor` `パラメータ`をサポートしない。指定すると `ParameterBindingException` が発生する。
* **理由**: コマンドレットの仕様を誤解したことによる単純なエラーだが、頻発しやすいため明記する。（開発哲学: 1, 5）

### 7.2. エラーメッセージの安全な展開（必須知識）

* **内容**: `catch` ブロックで `$_.InvocationInfo.Line` や `$_.Exception.Message` などのエラー情報を `Write-Host` や `Write-Error` で表示する際、展開される文字列がコマンドレットの`パラメータ`として誤認識されないよう、`'$($variable)'` のようにシングルクォートで囲むか、事前に文字列変数に格納するなどの注意が必要。これが `CommandNotFoundException` の原因となった。
* **例（悪い例）**: `Write-Host "Error at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)"`（もしMessageが `-Foo` で始まると問題）
* **例（良い例）**: `Write-Host "Error at line '$($_.InvocationInfo.ScriptLineNumber)': '$($_.Exception.Message)'"`
* **理由**: PowerShellの文字列展開とコマンド解析の挙動を理解し、意図しないエラーを防ぐため。（開発哲学: 1, 3, 5）

### 7.3. 変数の明示的な初期化（推奨）

* **内容**: 変数は、最初に使用する前（とくに値が代入される前）に、適切な型のデフォルト値で初期化することを推奨する（例: `$myString = ""`, `$myArray = @（）`, `$myInt = 0`, `$myObject = $null`）。
* **理由**: 未初期化変数による意図しない動作やエラーを防ぐ。`Set-StrictMode` を使用していても、初期化は良い習慣である。（開発哲学: 4）

### 7.4. マジックナンバー・ハードコーディングの禁止（推奨）

* **内容**: スクリプト内に直接記述された具体的な数値（マジックナンバー）や文字列リテラル（ハードコーディングされたパス、URL、固定`パラメータ`など）は避ける。
  * 設定値の管理: スクリプト冒頭の定数セクション（読み取り専用変数 `Set-Variable -Name MyConstant -Value "value" -Option Constant` や、`$Configuration` ハッシュテーブルなど）、または外部設定ファイル（JSON、XML、INIなど）で一元管理する。
  * `パラメータ`デフォルト値: スクリプト`パラメータ`のデフォルト値として定義する。
* **理由**: 設定変更の容易化、可読性の向上、typoの防止。（開発哲学: 1, 2）
* **例外**: 非常に自明な固定値（例: ループの初期値 `0` や `1`、配列の最初のインデックス `0` など）は許容。

### 7.5. 再帰関数の使用時の注意点（推奨）

* **終了条件**: 再帰関数には、必ず明確な終了条件（ベースケース）を設ける。
* **最大再帰深度**: PowerShellのデフォルトの最大再帰呼び出し深度に注意し、非常に深い再帰が予想される場合は、ループ処理への置き換えを検討するか、再帰深度カウンターを設けて意図しない無限ループを防止する。
* **理由**: 無限ループやスタックオーバーフローを防ぎ、安定した処理を保証するため。（開発哲学: 3, 4）

### 7.6. PowerShellバージョン互換性（意識）

* **内容**: スクリプトが特定のPowerShellバージョンに依存する機能を使用している場合は、その旨をコメントやドキュメントに明記し、可能であれば `#Requires -Version <バージョン>` を記述する。
* **フォールバック**: `ConvertFrom-Yaml` のように、利用できない場合の代替処理を実装することも検討する。
* **理由**: 異なる環境での動作の予測可能性を高めるため。（開発哲学: 4）

### 7.7. 複数AI支援ツール使用時（意識）

* **検証**: AIの提案は鵜呑みにせず、必ず自身で内容を理解し、テストして検証する。
* **情報提供**: AIに質問や依頼をする際は、正確かつ十分なコンテキスト（エラーメッセージ全文、関連コード、仕様、目的など）を提供する。
* **限界認識**: AIは万能ではなく、とくに複雑なロジックや環境固有の問題の解決には限界があることを理解する。
* **理由**: AIを効果的に活用しつつ、品質を担保するため。（開発哲学: 5）

## 8. AI協業ガイドラインの遵守

本プロジェクトにおいてAIアシスタントを開発に利用する場合、その協業プロセス、とくに実装やデバッグにおける具体的な手順は、プロジェクトの最上位ルールブックである **`docs/99_ai_collaboration_guideline.md`** の定義に厳格に従うこと。

## 9. 日付と時刻の解析に関する教訓（追加）

PowerShellにおける日付と時刻の文字列解析は、カルチャ設定やフォーマットの厳密性によって予期せぬ問題を引き起こすことがあります。

*   **`[datetime]::Parse()` の利用と注意点:**
    *   `[datetime]::Parse("日付文字列")` は、現在のシステムカルチャ設定に基づいて日付文字列を解析します。これは柔軟ですが、異なる環境での再現性を損なう可能性があります。
    *   **推奨:** `[System.Globalization.CultureInfo]::InvariantCulture` を指定することで、カルチャに依存しない一貫した解析が可能です。例: `[datetime]::Parse("2025/07/21 10:00", [System.Globalization.CultureInfo]::InvariantCulture)`
*   **`[datetime]::TryParseExact()` の利用と注意点:**
    *   `[datetime]::TryParseExact("日付文字列", "フォーマット文字列", ...)` は、指定された厳密なフォーマット文字列に基づいて解析を試みます。
    *   複数のフォーマットに対応する場合、`string[] formats` を受け取るオーバーロードを使用できますが、PowerShellのバージョンや環境によっては `[ref]` パラメータとの組み合わせでオーバーロード解決に失敗することがあります。
    *   **推奨:** 複数のフォーマットを試す場合は、`foreach` ループで各フォーマットを個別に `TryParseExact` に渡す方が堅牢です。例:
        ```powershell
        $parsed = $false
        $tempDateTime = $null
        $formats = @("yyyy/M/d HH:mm", "M/d HH:mm") # 試したいフォーマットの配列

        foreach ($format in $formats) {
            if ([datetime]::TryParseExact($dateString, $format, $null, [System.Globalization.DateTimeStyles]::None, [ref]$tempDateTime)) {
                $startDateTime = $tempDateTime
                $parsed = $true
                break
            }
        }
        if (-not $parsed) {
            Write-Warning "日付フォーマットを解析できませんでした: $dateString"
        }
        ```
*   **CSVからの日付文字列の処理:**
    *   CSVファイルから読み込んだ日付文字列には、曜日や「〜」などの余分な情報が含まれることがあります。正規表現で必要な日付と時刻の部分のみを抽出し、解析に適した形式に整形してから `Parse` または `TryParseExact` に渡すことが重要です。
    *   年が省略されている場合（例: `7/21 10:00`）は、現在の年を補完して `yyyy/M/d HH:mm` の形式に整形することで、解析の成功率を高めます。

## 10. エンコーディングに関する教訓（追加）

PowerShellにおけるファイルI/Oや標準入出力のエンコーディングは、文字化けの主要な原因となります。

*   **エンコーディング名の統一:**
    *   PowerShellのコード内でエンコーディングオブジェクトを直接使用する場合: `[System.Text.Encoding]::UTF8`
    *   PowerShellのコマンドレットの `-Encoding` パラメータや、`[System.Text.Encoding]::GetEncoding()` でエンコーディング名を文字列として渡す場合:
        *   UTF-8: `"utf-8"` (小文字、ハイフン)
        *   Shift-JIS: `"shift_jis"` (小文字、アンダースコア)
    *   **注意:** `"UTF8"` (大文字) や `"ShiftJIS"` (キャメルケース) は、環境によっては認識されない場合があります。
*   **標準出力のエンコーディング:**
    *   WSL環境や `cmd.exe` からPowerShellスクリプトを実行する場合、PowerShellの標準出力のエンコーディングがシステムのデフォルト（例: Shift-JIS）になり、UTF-8の出力が文字化けすることがあります。
    *   **推奨:** スクリプトの先頭で `$OutputEncoding = [System.Text.Encoding]::UTF8` を設定するか、`pwsh.exe` を `-Command` オプションで呼び出す際に `$OutputEncoding` を設定することで、出力の文字化けを防ぐことができます。
        ```bash
        pwsh.exe -NoProfile -ExecutionPolicy Bypass -Command "$OutputEncoding = [System.Text.Encoding]::UTF8; & 'C:\Path\To\Your\Script.ps1'"
        ```
*   **ファイルの読み書き時のエンコーディング:**
    *   `Get-Content` や `Out-File` を使用する際は、必ず `-Encoding` パラメータを明示的に指定してください。これにより、意図しないエンコーディングでの読み書きを防ぎ、文字化けのリスクを低減します。
    *   例: `Get-Content -Path "file.csv" -Encoding ([System.Text.Encoding]::GetEncoding("shift_jis"))`
    *   例: `Out-File -FilePath "output.ics" -Encoding UTF8` (PowerShell 7+では `UTF8` で問題ないことが多いですが、より安全には `[System.Text.Encoding]::UTF8` を使用)

## 12. デバッグ時の教訓

*   PowerShellスクリプトで`param()`ブロックが正しく解析されない場合、`param()`ブロックをスクリプトの先頭に移動することで解決することがある。

本プロジェクトにおいてAIアシスタントを開発に利用する場合、その協業プロセス、とくに実装やデバッグにおける具体的な手順は、プロジェクトの最上位ルールブックである **`docs/99_ai_collaboration_guideline.md`** の定義に厳格に従うこと。